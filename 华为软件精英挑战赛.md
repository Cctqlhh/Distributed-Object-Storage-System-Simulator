# 华为软件精英挑战赛

## 方向

### 完善全局预处理阶段

利于后续的写入策略优化

写一个预处理函数



### **预处理**

数据接收（三个二维向量）

每个标签在每个时间片组都有三个属性：删除对象总和	写入对象总和	读取对象总和



根据读取和写入 判断哪些标签热门（待定处理）





根据删除 辅助空间回收和碎片整理策略





根据删除和写入 预估和预留每个标签在硬盘上所需的连续空间大小。（三个副本）





是利用整体时间片组的所有操作对象大小之和		

还是利用每个时间片组的所有操作对象大小之和

可以二者进行结合



每一个标签	标签管理思想

一行 del 数据					总 del

一行 write 数据				总 write

一行 read 数据				总read





### 写入策略优化

**分析**

**写策略包括：**

**写什么：多个对象（id size tag）**

对象写入的优先级

先写最可能读取到的对象

这个好像不是问题，写入与磁头的位置无关，且立即生效。

所以不需要对象优先级？？？

我觉得也得需要

**往哪写：决策每个副本往哪个硬盘写**

标签聚合思想选择写入硬盘

**如何写：决策每个副本如何在对应的硬盘写入**



**问题**：

- 目前的写入方式 `(id + j) % N + 1` **可能会导致相同标签的对象分布在不同磁盘**，影响读取时的顺序性。
- **没有考虑磁盘负载，导致某些磁盘存储过多数据，而另一些磁盘存储较少**。

**优化思路**：

1. **基于标签的磁盘分配**：
   - 让**相同标签的对象存储在相近的磁盘**，减少未来的磁头移动成本。

这个肯定是后续要做的内容



1. **平衡磁盘负载**：
   - 让**空闲空间最多的磁盘优先存储新对象**，避免某些磁盘存储过载。

这个肯定是后续要做的内容



1、优先选择没有使用的最大容量的硬盘	往哪写

2、连续存储优化：优先选择连续，原本方案作为备选。	如何写

3、负载均衡优化：选择负载最小且未被使用的硬盘	等同于1 	往哪写

4、批量写入优化：按大小排序，先写入大对象。	写什么

5. 缓存热点数据	写什么



**写入策略**

标签聚合原则

连续空间分配原则

预留空间原则





























### 读取策略优化

**读取策略**















### 二者配合优化



| **优化方向** | **优化策略**                               | **提升点**                         |
| ------------ | ------------------------------------------ | ---------------------------------- |
| **写入优化** | 让**未来高频读取数据**存放在靠近磁头的磁盘 | **减少未来磁头移动**，提高读取效率 |
| **读取优化** | 选择**最近的副本读取**，减少 `Jump`        | **减少令牌消耗，提高吞吐量**       |
| **并行优化** | 让多个磁头同时读取不同对象                 | **提高磁盘并行性**                 |









### 添加完善部分

硬盘类添加使用大小属性

对象类添加标签属性



### 添加标签管理类

统计并分析 fre_del fre_write fre_read

统计 每个对象对应的标签	

统计 每个硬盘对应每个标签的数量	作为后续选择存储硬盘的标准



### 改善对象类

增加对象和请求读取该对象的id映射关系







### 3.17

**读取细节：**

个人感觉：给每个请求维护一个请求对象相同size的vector，内容是0或1,0代表该请求的对象未读，1代表该请求的对象已读。

我现在感觉这个是非常非常非常关键的，这样也能够知道这个读取请求是否被完成读取。方便后续能够对这个读取请求进行完成上报。

我觉得这个还是挺关键的，在处理这个读取请求的时候，如果发现这个请求的后一些部分被读取过，且后续没有连续读的对象，那就可以直接pass掉或者jump掉；如果后续有需要连续读的对象，可最好还是再次read一遍，避免read从64开始。

这里可以添加一个判断，如果目前对象块已经被读过，那么

​	若维持正常读取下去到下一个读取对象读取第一个块，计算消耗的token数量

​	若pass到下一个读取对象读取第一个块，计算消耗的token数量

​	二者比较，哪个数量小选择哪种方式。

而且尽早上报完成请求能够避免得分衰减，使得得分更高。

所以需要完善request类的成员属性，比如

```CPP
vector<bool> block_read;            // 每个块是否已读取
int remaining_blocks;               // 剩余未读取的块数
```

还是说

给每个对象添加读取请求完成情况数组?

我选择完善request类的成员属性。





**读取步骤：**

🟢 Step 1：更新当前的读取请求队列

每个时间片开始时，接收所有新到达的读取请求，将它们加入各自磁盘的优先级队列。

🟢 Step 2：每个磁头选择读取任务

🟢 Step 3：执行读取

🟢 Step 4：维护读取请求完成情况

维护每个读取请求中的读取进度相关的属性

🟢 Step 5：移除已完成的请求

当对象所有块被读取完毕时，从所有磁盘的请求队列中删除该请求

🟢 Step 6：执行特殊优化

**最后 105 个时间片：集中完成未读任务**

- 遍历所有磁盘，**优先读取剩余未完成的对象**



**发现：**

读取空单元和无读取请求的对象块是合法操作，即可以通过连续读取替代pass，

当遇到无读取请求的对象块或空单元，是选择pass还是选择read

（1）计算连续读直到下一个需要读取对象的第一个对象块且读取完毕所需要的总token，

```
(1+(p2-p1))*readi
```

（2）计算连续pass直到下一个需要读取对象的第一个对象块且读取完毕所需要的总token，

```
(p2-p1)+64
```

若（1）>（2），则选择（2）的方式 pass

```cpp
(1+(p2-p1))*readi	>	(p2-p1)+64
```

若（1）<（2），则选择 （1）的方式 read

```
(1+(p2-p1))*readi	<	(p2-p1)+64
```





## 讨论

### 3.12

![image-20250313103143463](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20250313103143463.png)

连续读8次就会到达最低的16令牌消耗



读取优先级队列的生成因素：

请求出现的时间

离磁头的距离

判断与当前正在读取是连续读取关系，根据磁头距离

删除概率

标签因素体现在连续读取 当前策略中





写入策略还需要进一步完善

写入时考虑剩余空间 负载情况等



对象的划分：

根据 标签的删除频率、写入频率、读取频率 划分对象



### 3.15

发现的问题：

![Figure_1](D:\研究生资料\竞赛资料\2025华为软件精英挑战赛\笔记资料\Figure_1.png)

前面8个标签的数据先升到最大，然后后8个标签的数据后升到最大。

16个标签数据并不是同时到达最大值，所以如果同时预留最大空间，会导致硬盘空间不够用。



### 3.16

**整体思路梳理**

**数据预处理阶段：**（这些处理代码需不需要直接写在源程序里面？**预处理阶段的这些处理步骤通常需要直接写在源程序（main程序）里面**，尤其是本次比赛的题目，明确提供了一个预处理的时间段让你进行准备操作。）

1、根据删除、写入数据量确定每个标签的累积总大小

2、根据读取数据量确定每个标签的热度，防止热度重合

3、硬盘划分为二维存储区域，每个硬盘均分为**20**个区间块，即所有硬盘总共划分为100个区间块**（后续需调优）**（确定区间块的划分）**√**

​	硬盘划分区域策略：

​	划分区间块多了，每个区间块的大小更小，更加细致，多分浪费的空间更小，但标签更零碎（若采用按需分配策略，则可减缓）；划分区间少了，每个区间块的大小更大，更加粗糙，多分浪费的空间更大，但标签更聚合。

**一般推荐做法是：**

- 初期先按照100区间这种粒度尝试；
- 后续根据实际使用情况（碎片化程度、读取效率）再适当微调。

4、根据每个标签的累积总大小和标签热度确定初始区间块分布（固定分配的区间块）（后续需调优）（确定标签与区间块的映射关系）

​	这个分配策略非常关键，直接影响后续的读取效率。

​	**讨论问题：**每个区间块是否划分为三个小块？**讨论策略：**否，应该把每个标签选择的三个区间块错开放置，可以规定一定的区间块间隔放置。（间隔多少？）

​	**初始分多大**

​	（1）按需分配策略：需求大的标签，分配的区间块多；需求小的标签，分配的区间块少。分配的这些区间块都是横向连续，即在同一个磁盘上。

​	（这是在解决优先满足哪个标签存储容量需求的问题，按常理来说，谁先存储需求多，先满足谁，可是有些标签存储需求不大，但读取请求峰值很高，比如9号标签）

​	我觉得就是先按照存储需求来分配，暂时不考虑读取请求。

​	待定

​	**初始分哪里**

​	（2）混乱分配策略：每个硬盘上的标签种类尽量各不相同，以随机性降低可能出现的读取请求火热的情况。

​	（3）细粒度峰值错开策略：对于当前待分配标签i，遍历10个硬盘，选取**在该标签峰值时刻负载最低**的硬盘分配。

​	（4）硬盘存储容量均衡策略：优先选择剩余存储容量大的硬盘。

5、剩余一部分自由区间块

**数据预处理阶段功能：**

1、统计初始的数据矩阵（删除、写入、读取数据）；

2、在主程序启动后立即执行上述“空间划分”和“标签映射策略”等预处理工作；

**数据预处理阶段结果分析：**

数据预处理结束之后，二维硬盘整体分为两部分，一部分为固定区间块，初步分配给各个标签使用的区间块，一部分为自由区间块，后续哪个标签先需要，就分给哪个标签。



**数据删除、写入、读取交互阶段：**

1、删除

2、写入

​	写入策略：先在固定区间块中插空，若没空可用，则使用固定区间块中的连续区间块；若没有连续区间块，则使用一个新的自由区间块（添加新自由区间块的选择策略）；若没有新的自由区间块，则使用一个已使用区间块（添加已使用区间块的选择策略）。最终必须保证对象写入成功。

​	新增的写入策略：是否在需要开辟新的区间块之前数据可以拆分存储，以优先填满现有的区间块

**写入策略建议（非常关键）：**

你提出的写入策略较为全面，稍作补充和明确：

**空间快分类：**（分类比例可调）

完全自由区间块：

​	初始完全自由区间块：默认

​	后处理完全自由区间块：需要记录先前标签，若先前标签需要开辟新空间，则优先选择该区间块。

部分自由区间块：剩余空间大于3/4

不自由区间块：剩余空间小于等于3/4

**分配空间未用完:**

1. **优先在固定分配区间块内插空**

2. **若无空闲单元，优先在固定区间块内寻找连续空间堆**（减少磁头移动）

   ​	暂定策略：

   ​	若磁头后有空间，磁头后从左往右碎片空间碎片插，连续空间连续堆
   ​	若磁头后无空间，磁头前从左往右碎片空间碎片插，连续空间连续堆

   （简单策略：先从左往右整体插入，若不能整体插入再对象块拆开插。）

   （磁头附近集中插入？）

**分配空间已用完:**

1. 若固定区间块空间完全用完，则**启用自由区间块**，根据当时硬盘剩余空间大小动态选择（存在自由区间块即可选择）。**（标签对应后处理完全自由区间块 -> 初始完全自由区间块 -> 后处理完全自由区间块 -> 部分自由区间块）**

   添加新自由区间块的选择策略：对于**需开辟新空间**的标签i，计算该标签与10个硬盘中含有的**冲突数**，冲突数是 冲突矩阵第i行中硬盘中含有标签对应的所有列的和。

2. **自由区间块也用完后**，再选择**已有标签的区间块**，根据剩余空间选择（多标签共存策略）。**(不自由区间块)**

   添加已有标签区间块的选择策略：w1 * 冲突情况得分 + w2 * 标签剩余空间得分

   冲突情况得分：冲突矩阵归一化（多个分数选高的）

   标签剩余空间得分：max(|当前容量-1/2区间块容量|)

   得分归一化（量级）

   （考虑因素：冲突情况、剩余空间大小）

（

当进入多标签共存阶段后，建议**区间内部仍然保持“按标签分割”**，防止碎片化严重：

- 当某个区间块首次进入第二标签数据时，区间可对半划分（标签1左半、标签2右半），避免碎片交叉。
- 若引入第三标签，同样按比例进一步划分子区域。

）



3、读取（后续需要一个读取策略）

​	读取策略：每个磁盘（或磁头）设置一个读取对象的优先级队列，通过优先级队列来主动知道需要读取哪个对象。

​	新增的读取策略：不是以对象整体思想看待对象，而是以对象块拆分思想看待对象，比如需不需要维护一个相同size大小的01向量来确定这个对象哪些对象块需要被读，哪些对象块不需要被读。

**读取策略建议（非常关键）：**

你的策略框架缺乏读取策略，这里补充一个高效的读取策略：

- **短寻道优先 (SSTF) 调度算法为主**
  - 磁头每次选择当前位置距离最近的请求存储单元执行；
  - 若请求对象分布较散，可以使用电梯调度（SCAN）策略，统一一个方向处理请求，避免来回移动造成token浪费。
- **读取请求副本选择优化**
  - 每个对象有3个副本，优先选择所在硬盘磁头距离最近的副本；
  - 动态规划每个磁头每个时间片的token预算，选择“连续读”优势大的副本（连续读token衰减更快）。
- **热点数据预读（缓存思想）**
  - 根据热度统计数据，提前将高频标签数据副本分散在多个盘内，多个磁头同时处理热点读取请求。





4、最后105个时间片特殊处理，使得最终得分能够在当前条件下尽可能高（后续需要一个特殊处理策略）

最后105个时间片并非不做任何操作，反而是专门用来“集中处理此前积压的读取请求”的关键时间；

在交互后期（无新请求时）：

- **步骤1：梳理未完成请求**
  - 整理所有尚未完成读取的对象块；
- **步骤2：重新确定磁头调度计划**
  - 集中所有磁头精力完成这些未完成请求；
  - 根据请求延迟分数降幅，合理规划磁头行动次序。
- **步骤3：高效完成**
  - 在无外部干扰时（无写入、删除新请求），集中资源完成读取；
  - 尽快完成，尽早上报请求完成，获取更高得分。













1、在固定区间块中进行数据删除、写入、读取

​	（1）删除

​	（2）写入

​	写入策略：先在固定区间块中插空，若没空可用，则使用固定区间块中的连续区间块；若没有连续区间块，则使用一个新的自由区间块（添加新自由区间块的选择策略）；若没有新的自由区间块，则使用一个已使用区间块（添加已使用区间块的选择策略）。最终必须保证对象写入成功。

​	（3）读取（后续需要一个读取策略）

​	读取策略：

2、待固定分配的区间块填充完毕之后，使用新的自由区间块（后续需要一个选定策略）

​	删除

​	写入（优先插空，然后选择连续空间）

​	读取（后续需要一个读取策略）

3、待新的自由区间块选定完毕之后，没有新的自由区间块，再挑选已经存放一个标签的区间块，按照剩余区间块大小选定。（后续需要一个选定策略）

​	删除

​	写入（优先插空，然后选择连续空间）（后续需要在双标签区间块中的写入数据策略）

​	读取（后续需要一个读取策略）

4、待已经存放一个标签的区间块全部选定之后，再挑选已经存放两个标签的区间块，按照剩余区间块大小选定。（后续需要一个选定策略）

​	删除

​	写入（优先插空，然后选择连续空间）（后续需要在三标签区间块中的写入数据策略）

​	读取（后续需要一个读取策略）

5、……

6、最后105个时间片特殊处理，使得最终得分能够在当前条件下尽可能高（后续需要一个特殊处理策略）

​	

## 问题

1、能边scanf边printf吗？

也可以



2、ceil(110/1800)=1	样例给的这个是 T+105，而不是直接用T，和任务书冲突

没关系



3、如果两个请求请求的是同一个对象id，我在两个请求到达之后再进行这个对象的读取，那是不是读取一遍就可是同时完成多个读取请求？

**是的，你的想法完全正确！**
 如果**多个请求请求的是同一个对象 ID**，那么你可以**只读取一次该对象的全部对象块**，然后在这一时间片内**同时完成所有对应的读取请求**，避免重复读取，大幅减少**磁头移动和令牌消耗**，提高得分。



4、我在读当前对象的过程中，新来了一个读取请求要读取该对象，此时这个对象的旧请求和新请求共用了这个对象的后半部分读取，在旧请求完成之后，新请求是只读未完成读取的对象块部分还是再次读取完整对象。

